# Javascript

High-leveled

-   memory management and garbage collection
-   easily human readible

Interpreted

-   browser reads the code line by line

Multi-paradigmed

-   supports multiple programming paradigms, such as procedural, object oriented, and functional

Dynamically Typed

-   no static type checking, no need to declare variable types, reassign them whenever

Singled Threaded

-   runs off the event loop, multi-threading is not possible

It is the most commonly used client-slide scripting/programming langauge

-   Runs on the browser
-   Primarily used to create dynamic webpages
-   Runtimes such as NodeJS which allow it to run outside of the browser

Javascript follows the specifications set out by ECMAScript

-   This is where JS gets its versions
-   For example some JS versions are ES5, ES6, ES7, ES2020

## Linking your HTML and JS

HTML supports the use of Javascript, with the `<script>` tag, you can either write JS directly inside of these tags or you can link an external file

-   Java script written inside of the script tags is called **Internal Javascript** and Javascript writeen in a different file is called **external javascript**
-   The script tag can go in the head or the body, best practice is the bottom of the body
-   To use an external JS file, you use the `src` attribute with a path to the external file

## Syntax and Variables

Syntax Rules:

-   Case sensitive
-   Semicolon are optional
-   Spacing doesn't matter
-   Single and multi-line comments (are the same as java)

Javascript variables:

-   Used to store data/values
-   Use the keywords `var`, `let`, and `const` to declare
-   Variables have a name and use the equals sign to assign them a value
-   Cannot be name a keyword, cannot start with a number or specicial character (except for $ \_) and cannot contain spaces
-   Literals in javascript are fixed values, aka you primitives

# Data Types

Javascript has 7 primitive datatypes:

-   string
-   number
-   boolean
-   null
-   undefined
-   object
-   Symbol (we will talk more about these later on)

Strings in Javascript

-   Simply text enclosed by single or double quotes

Numbers in Javascript

-   Can be positive or negative
-   Can be decimal or non-decimal
-   Include the special datatypes including infinity and NaN

Boolean in Javascript:

-   Simple true or false

Null in Javascript:

-   null refers to nothing
-   It is not the same as empty string or 0

Undefined in Javascript

-   Variable was declared but not initialized
-   var x;

Objects in Javascript

-   A set of key value pairs, the key is a string, the value can be anything, including another object or an array
-   You can access the object properties (values) using dot notation or brackets

# Type coercion

the process of converting a value from one datatype to another

There are two types of type coercion, explicit and implicit

-   Explicit occurs when we specify that we want the type changed to a new type
    -   `var num = new Number("3")`
-   Implicit occurs when JS will attempt to carry out your instructions by changing the type of the variable
    -   `var div = "3"/4`

# Arrays

An object that stores a list of values

-   Allowed to store any and all data types in a single array
-   Index starting at 0
-   Values can be accessed by the associated index inside of brackets
-   Arrays also include a property called length that indicates the number of elements in the array
-   Arrays are dynamic, the size will automatially grow as you add items
-   Arrays come with several built in methods:
    -   .push()
    -   .pop()
    -   .foreach()
    -   .filter()
    -   .map()
    -   .slice()

# Operators and Control Flow

Javascript operators perform some operation on single or multiple operands and produce a result

There are five types of operators in Javascript:

-   Arithmetic: -, +, \*, /, %, ++, --
-   Comparison: ==, ===, !=, >, <, >=, <=
-   Logical: &&, ||, !
-   Assignment Operators: =, +=, -=, \*=, /=, %=
-   Ternary Operator: condition ? value : value

Control Flow Statements:

-   if/else
-   for
-   for in
-   for of
-   while
-   do while

## Difference between == and ===

-   They both are used for comparison between objects
-   == compares two variables and does not take into account their data types
-   == has the ability to convert the datatypes to match in the comparison
-   === compare two variables and will check for strict type, meaning it checks to see if the type and the value are the same
-   === will only return true if the datatype and value match

### TLDR: === does strict comparison, type and value must be equal, == only checks the value

## Truthy and Falsy in Javascript

In Javascript any expression or value that results in the boolean false is considered falsy, these include:

-   boolean false
-   empty string ''
-   Undefined
-   Null
-   NaN
-   0

Everything else is considered truthy

# Functional Programming in JS

One of Javascripts many paradigms is functional programming, in this paradigm programmers attempt to break their entire program into small "pure" functions, whose main focus is "what to solve" instead of "how to solve". Typically, in functional programming your functions are simply expressions that will produce the same output every single time give the same inputs.

However, in Javascript we don't have to strictly follow this convention of "pure" functions, instead, we will be breaking our client side logic into these reusable functions that can be called from anywhere in the script. The important thing to take away from functional programming, is the use of functions themselves.

## Pass by value
In JavaScript, all function arguments are passed by value. This means that the value of any variable passed to a function is copied into the argument of the function. Any changes you make to the argument will not be reflected in the variable outside of the function.

# Functions

a peice of resubale code that can be called anywhere in the program

-   defined using the `function` keyword, and they can take as many parameters as you wish
-   you can use the `return` keyword if you want to return something

## Function Expressions:

known as an anonymous function, have no identifier/name, and are stored in a variable. This is possible because everything in Javascript is an object

-   example: `let func = function(){console.log(hello)}`

## Self-Invoking Functions / IIFE Functions

A self-invoking function is an anonymous function that is invoked immediately after its definition. It is also known as the IIFE (Immediately Invoked Function Expression) function.
It holds an anonymous function inside a set of parentheses (), which does the execution.

Syntax : `(function(){ code goes here...})();`

Example:
```javascript
(function(){
    // do this right now
    console.log("Look at me, I'm running");
})();
```


## Callback Function

a function that gets passed into another function as a parameter, then get executed once the original function is complete

-   This is helpful with asynchronous code
-   All functions are objects, so they can be passed as parameters to other functions
-   A callback function can also be created using the keyword callback

## Default Paremeters:

allow programmer to set a value to a function parameter incase no value is passed to the function



# Variable Scopes

The scope of a variable defines the lifetime and visibility of a variable in a Javascript program

-   the variable cannot be accessed outside of its scope

Two major divisions of scope: Global and Local

## Global Scope

accessible everywhere in the application, it has the lifetime of the application

## Local Scope

accessible only in their location

Local Scope is broken into Function and Block Scope

## Function Scope:

variables declared inside of a function are only accessible inside of the function, and their lifetime is the span of the function

## Block Scope:

Introduced in ES6, variables with the keyword `let` and `const` can only be accessed inside of their block code, lifetime again is just the span of that block of code

## Lexical Scope

Lexical scope is that a variable defined outside a function can access the inside another function defined after the variable declaration. The inner functions are lexically bound to the execution context of their outer functions.

Example:
```javascript
function func1(){
    var animal1 = "Lion";   //exist in Lexical scope

    function func2(){    //Inner Function

        var animal2 = "Tiger"; //exist in function scope
        console.log(animal1);
        console.log(animal2);

    }
    func2();
    console.log(animal2); // results error - due to it exist in function scope
}

foo1();
```
The result will be:
```
Lion
Tiger
error: animal2 is not defined
```


# Hoisting:

variables and functions are moved to the top of their scope before code execution

-   Only the declarations are hoisted, not the assignments
-   Only variables declared with the var keyword are hoisted out of block scope

# ES6 Features

# let and const keywords

let and const were introduced in ES6 as means of preventing hoisting from block scope

The let keyword allows you to declare a variable in block scope without it being hoisted

The const keyword also allows you to delcare a variable in block scope without being hoisted, except it is treated as a constant, so you cannot reasign it

It is now considered best practice to use let and const over the var keyword

# Arrow Functions:

-   a new simplified way to write concise functions
-   lookes like this `let func = (args) => expession`
-   Multi-line arrow functions must have curly braces around the expression

# Template Literals

Template literals are an easy way to create multi-line strings and perform string interpolation

-   Template literals are Strings that are enclosed by backticks `
-   It allows for embedded expressions, placeholders indicated by a dollar sign and curly braces `${expression}`
-   These expressions can be used to evaluate functions, or variables

# this keyword

The `this` keyword had multiple meanings based on where its used

-   `this` alone refers to the global window object
-   `this` in event handlers refers to the HTML element that receives the event
-   `this` in object method binding refers to the object

# strict

Declaring "use strict" in Javascript means that you will not be allowed to use:

-   undefined variables
-   any keyword as variable or function names
-   restricts some other nichee instances


# DOM

## Document Object Model (DOM):

Tree like structure representing the HTML document known as the DOM tree

-   Allows javascript to access and manipulate elements and styles on a webpage

The root of the DOM tree is our HTML tag, otherwise known as the document object

-   Every other element is a node that can be accessed via Javascript

To gain acess to the DOM you simple use the `document` object in Javascript, it gives you access to methods to select elements, traverse and manipulate the HTML Page

# Selecting Elements and Traversing the DOM

There are several ways to select an element in the DOM tree:

-   `document.getElementById("idname")`: select a single element based off of its id attribute
-   `document.getElementsByClassName("classname")`: select a group of elements with the same class attribute
-   `document.getElementsByTagName("tag")`: select all elements with that specified tag
-   `document.querySelector("selector")` and `document.querySelectorAll("selector")`: select an element/s with a specified CSS selector

The document object provides us ways to move through the tree with different properties gaining access to pretty much any object in the tree

To gain access to the top most nodes you can use:

-   `document.documentElement` to access the html element
-   `document.head` to access head tag
-   `document.body` to access body tag

To gain access to the parent nodes of the currently selected element

-   `element.parentNode`
-   `element.parentElement`

To gain access to children nodes of an element:

-   `element.childNodes`
-   `element.firstChild`
-   `element.lastChild`

To gain access to sibling nodes of an element:

-   `element.previousElementSibling`
-   `element.nextElementSibling`

# DOM Manipulation

On top of access, and traversing through the tree, you are also able to change/manipulate elements in the dom three with JS

-   `document.createElement()` you can create an element and insert into the dom tree
-   `element.replaceChild()` remove an element from the DOM and replace it with another
-   `element.removeChild()` to completely remove and element
-   `element.insertBefore()` to insert an element before the selected one
-   `element.innerText` and `element.textContent` to change, set, or get the text in an element
-   `element.innerHTML` to set the HTML of an element
-   `element.cloneNode()` used to clone an element

There are also many other useful methods and properties that you can leverage on the element objects to manipulate the page in JS

You can use these methods to manage attributes of html elements:

-   `element.getAttribute("attname")`
-   `element.setAttribute("attname")`
-   `element.removeAttribute("attname")`
-   `element.hasAttribute("attname")`

# Events and Listeners

Events occur when a user interacts with a webpage, or when the browser triggers one

You can configure your webpage to handle these events with Javascript using event handlers, events you can handle include:

-   onclick: this is a click event occurs when a user clicks the element on the webpage

-   ondblclick: this is a click event occurs when a user double clicks on element on the webpage

-   onload: this is a load event occurs when the browser is finished loading the page

-   onunload: this is a load event occurs when a user closed the document

-   onresize: this is a load event occurs when the browser window is minimized or maximized

-   onmouseover: this is a mouse event occurs when a user mouses over an element

-   onmouseout: this is a mouse even occurs when a user moves the mouse off of an element

-   onkeydown, onkeyup, are keyboard events occur when a user presses or releases a key

-   onfocus: this a form input event occurs when the user gives focus to an element on the webpage

-   onblur is the opposite of on focus

-   onchange: this is a form event that occurs when a user changes the input in a form

-   onsubmit: this is a form event that occurs when a user submits a form

There are three ways you can register an event handler:

1. Inline, where you set the on... attribute of the html element to a predefined function in your js code
2. You can set the event property of the html element to a predefined JS function
3. You can use the `element.addEventListener(event, function, useCapture)`

# The Event Object

In Javascript events are represented by an Event Object

Event Objects have the following properties and methods:

-   bubbles: a boolean value which indicates the propagation method, it is true by default
-   currentTarget: a reference to the DOM element whose event listener triggered the specific event
    -   This is different from the event that initally triggered the event as a single event can trigger multple event listeners through propagation
-   preventDefault(): cancel the event/prevents the default action of the event
-   stopPropagation(): prevents the event from propagating further
-   target: a reference to the DOM element that triggered the event
-   timeStamp: the time of the event in miliseconds
-   type: the type of the event

## Types of Events

There are several subclasses of the Event Object, which all include their own properties as well as the properties of the event object

-   A complete list of event objects can be found here: https://www.w3schools.com/jsref/obj_events.asp

## MouseEvent

This is an event that is generated when the user interacts with elements on the page with a mouse

Events like click, onmouseenter, onmouseleave, and so create mouse event objects

The MouseEvent object has many properties that hold information about the state of the machine when the event occured:

-   Coordinates of the mouse relative to the window: clientX and clientY
-   Coordinates of the mouse relative to the last event: movementX, movementY
-   Coordniates of the mouse relative to the target: offsetX, offsetY
-   Coordinates of the mouse relative to the screen: screenX, screenY
-   Whether alt, ctrl, or shift were held when clicking: altKey, ctrlKey, and shiftKey
-   Which mouse button was hit: button, buttons, which

## KeyboardEvent

This is an event that is generated when the user interacts with elements on the page with their keyboard

You would typically use this to add funcionality to webforms

Events onkeydown, onkeypress, and onkeyup create KeyboardEvent objects

This object has the following properties:

-   Whether alt, ctrl, or shift were hit during the event: altKey, ctrlKey, shiftKey
-   Which key was hit: key, keycode, and which
-   Whether the key is being held down: repeat

# Bubbling/Capturing

Javascript has something called event propagation, which essentially how the event flows through the components on the page

There are two ways in which an event can propagate, the first is called bubbling, the second is called capturing

## Event Bubbling

Bubbling is the default event propagating for event listeners

-   Follow a bottom up approach
-   The event starts at the target element, then "bubbles" its way up the tree

Essentially when an event happens, it first goes to any handlers on that element, then that elements parents, then grandparents, and so on until it reaches the top of the html document

Bubbling works for all handlers, regardless of how they are registered

## Event Capturing

Event capturing is the opposite of bubbling, instead of going from the target element to the top of the tree, it will start at the top and work its way down to the target element

-   Following a top down approach

Capturing only works with event handlers that are registered with .addEventListener() with an added third argument that is set to true

# Intro to Asynchronous Javascript

program does not need to wait for a specific task that takes a long time

It simply start executing the function, then moves on to the next function while it finishes

-   You can send a request/start a lengthy function, and forget about it
-   Then when you receive the reponse/the function is finished you can handle it
-   You program does not need to wait for the response in the mean time

This is useful with API calls, and other processes that could hold up or "block" the execution of your programs main thread

## How Asynchronous Javascript Works

Javascript implements a stack where functions calls are stored

-   It uses a single thread to add, and call functions on the stack one at a time, until the stack is empty
-   This is how basic synchronous programming works

Javascript also has a built in queue, and the browser/node runtime environment has extra threads that can used by Javascript, the queue is used by the event loop

## Javascript Event Loop

When an asynchronous call happens, Javascript allows the browser thread/web api to handle the specific call, while moving on in the stack

Once the web api is done processing the function, it will return the callback or the response to the queue, then the next time the call stack is empty, the event loop will return response/callback from the queue

## Basic Animation of the event loop

```javascript
const foo = () => console.log("First");
const bar = () => setTimeout(() => console.log("Second"), 500);
const baz = () => console.log("Third");

bar();
foo();
baz();
```

<img src = "https://res.cloudinary.com/practicaldev/image/fetch/s--BLtCLQcd--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_66%2Cw_880/https://devtolydiahallie.s3-us-west-1.amazonaws.com/gif14.1.gif">

## Basic Steps of the Event Loop in JS

1. Asynchronous call gets added to the stack
2. JS decides to hand it off to the web api where it processes
3. Other functions can be added and executed on the call stack while the web api works
4. Once the web api has a response it gets added to the queue
5. The event loop checks the queue when the call stack is empty to see if something needs to be added to the call stack
6. Our response/callback is added to call stack and process as normal

https://blog.bitsrc.io/understanding-asynchronous-javascript-the-event-loop-74cd408419ff

# Promises

Javascript uses promises for async opperations, they are placeholders for a future value. Many async functions return implicitly

Promises in Javascript are objects, and you create them using the new keyword

Promises take a callback function called the executor, this automatically runs the when the object is created

-   The executor also takes two callbacks, resolve and reject
    -   `resolve(value)` return the result of the job once it finishes sucessfully
    -   `reject(error)` is called when there is an error with processing the job

Promises have a property called status which gives us information about the state of the object. The promise can be in one of three states

-   pending
-   fulfilled
-   rejected

The promise objects connects the executor and any consuming functions which will receieve the result or the error from the promise

You would use `.then()` `.catch()` and `.finally()` methods on the promise object to consume (chain) the results or errors of the promise object

# Fetch API

fetch is a more modern and versatile way of making AJAX requests
The fetch API is provided by the window object, and provides the `.fetch()` method

-   `.fetch()` is used to send requests and returns a promise that is retrieved from the response
-   Successful requests get resolved, the returned promise will have the response body
-   Request that return an error HTTP-Status will be rejected

There are various methods you can use to access the response body of a success request:

-   `response.text()` read the response and return as text
-   `response.json()` parse the response as JSON
-   `response.formData()` return the response as FormData object
-   `response.blob()` return the response as Blov (binary data with type)
-   `response.arrayBuffer()` return the response as an ArrayBuffer (low level representation of binary data)

# async/await

introduced in ES8 to simplify asynchronous functionality

The async keyword denotes that a function will operate asynchronously via the event loop

-   Any function with the async keyword will implicitly return a promise object
-   Yuo can use any of the consumer function on the return of an async function, however there are nicer ways to handle these promises using await

The await keyword only works inside of async functions

-   await tells Javascript to wait for a promise to resolved before moving on
-   You can use await when calling any function that returns a promise, but it must be inside of an async function
-   It allows you to gather data, or wait for something while also not blocking the main thread

You no longer need to chain consumer functions together, making your code easier to read